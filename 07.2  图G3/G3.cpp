//《数据结构（C++版）（第3版）》 作者：叶核亚
//7.2.1   图的邻接矩阵表示和实现
//【例7.1】图的存储及操作。
//带权无向图G3

#include "MatrixGraph.h"
//#include "AdjListGraph.h"
 
int main()
{
/*//    MatrixGraph<char> graph1;                           //构造空图，顶点数为0
    AdjListGraph<char> graph1;                           //构造空图，顶点数为0
    cout<<"空图，"<<graph1<<endl;

    char vertices[]="ABCDE";                               //顶点集合
    MatrixGraph<char> graph2(vertices, 5, NULL, 0);     //没有边
//    AdjListGraph<char> graph2(vertices, 5, NULL, 0);     //没有边
    cout<<"图，"<<graph2<<endl;
*/
    //例7.1，图7.13
    char vertices[]="ABCDE";                               //顶点集合
    Triple edges[]={Triple(0,1,45), Triple(0,2,28), Triple(0,3,10),
                  Triple(1,0,45), Triple(1,2,12), Triple(1,4,21),
                  Triple(2,0,28), Triple(2,1,12), Triple(2,3,17), Triple(2,4,26),
                  Triple(3,0,10), Triple(3,2,17), Triple(3,4,15), 
                  Triple(4,1,21),  Triple(4,2,26), Triple(4,3,15)};   //G3边集合（除F），每条边两次
    MatrixGraph<char> graph(vertices, 5, edges, 16);
//    AdjListGraph<char> graph(vertices, 5, edges, 16);
    cout<<"带权无向图G3（除F）（图7.13），"<<graph<<endl;
   
    int v = graph.insertVertex('F');                       //插入顶点F，可能扩容
    Triple e1(v-2,v,13);
    graph.insertEdge(e1);                                  //插入边(D,F,13)
    graph.insertEdge(e1.symmetry());                       //插入边(F,D,13)
    cout<<"插入顶点"<<graph.getVertex(v)<<"，插入边"<<e1<<"，"<<e1.symmetry()<<endl;
    cout<<"带权无向图G1（图7.9），"<<graph<<endl;

    cout<<"深度优先遍历非连通图，无向图G1："<<endl;
    for (int i=0; i<graph.vertexCount(); i++)
        graph.DFSTraverse(i);
    cout<<"广度优先遍历非连通图，无向图G1："<<endl;
    for (int i=0; i<graph.vertexCount(); i++)
        graph.BFSTraverse(i);

    Triple e2(v-1,v,11);
    graph.insertEdge(e2);                                  //插入边(E,F,11)
    graph.insertEdge(e2.symmetry());                       //插入边(F,E,11)
    cout<<"插入边"<<e2<<"，"<<e2.symmetry()<<endl;
    cout<<"带权无向图G3（图7.11），"<<graph<<endl;

    graph.minSpanTree();                                   //Prim算法，构造带权无向图的最小生成树 

    cout<<"\nDijkstra算法，单源最短路径及长度\n";
    for (int i=0; i<graph.vertexCount(); i++)              //每对顶点之间的最短路径
        graph.shortestPath(i);                             //顶点vi的单源最短路径，Dijkstra算法
    cout<<endl;

//    cout<<"Floyd算法，每对顶点间的最短路径\n";
//    graph.shortestPath();                                  //最短路径，Floyd算法
/*
    v = 3;
    cout<<"删除顶点"<<graph.getVertex(v)<<"，";
    graph.removeVertex(v);                                 //删除顶点D
    cout<<"带权无向图G3（图7.14 b），"<<graph<<endl;

    Triple e3(v,v+1,9999);
    graph.removeEdge(e3);
    graph.removeEdge(v+1,v);
    cout<<"删除边"<<e3<<"，("<<graph.getVertex(v+1)<<","<<graph.getVertex(v)<<")，";
    v = graph.insertVertex('G');
    graph.insertVertex('H');
    graph.insertVertex('I'); 
    graph.insertVertex('J'); 
    graph.insertVertex('K');
    cout<<"插入顶点"<<graph.getVertex(v)<<"，"<<graph<<endl;

    cout<<"删除顶点";
    while (v < graph.vertexCount())
    {
        cout<<graph.getVertex(v)<<"，";
        graph.removeVertex(v);
    }
    cout<<graph<<endl;

/*    //习题7
    cout<<"有"<<graph.edgeCount()<<"条边，";
    int i=3;
    char vertice = graph.get(i);
    cout<<"顶点"<<vertice<<"的入度为"<<graph.indegree(i)<<"，出度为"<<graph.outdegree(i)<<endl;
*/
    system("pause");
    return 0;
}


/*
程序运行结果如下：
空图，顶点集合：()
邻接矩阵：

图，顶点集合：(A, B, C, D, E)
邻接矩阵：
     0    ∞    ∞    ∞    ∞
    ∞     0    ∞    ∞    ∞
    ∞    ∞     0    ∞    ∞
    ∞    ∞    ∞     0    ∞
    ∞    ∞    ∞    ∞     0
邻接表：
0 -> ()
1 -> ()
2 -> ()
3 -> ()
4 -> ()

插入顶点F，插入边(3,5,13)，(5,3,13)
带权无向图G1，顶点集合：(A, B, C, D, E, F)
邻接矩阵：
     0    45    28    10    ∞    ∞
    45     0    12    ∞    21    ∞
    28    12     0    17    26    ∞
    10    ∞    17     0    15    13
    ∞    21    26    15     0    ∞
    ∞    ∞    ∞    13    ∞     0
邻接表：
0 -> ((0,1,45), (0,2,28), (0,3,10))
1 -> ((1,0,45), (1,2,12), (1,4,21))
2 -> ((2,0,28), (2,1,12), (2,3,17), (2,4,26))
3 -> ((3,0,10), (3,2,17), (3,4,15), (3,5,13))
4 -> ((4,1,21), (4,2,26), (4,3,15))
5 -> ((5,3,13))

深度优先遍历非连通图，无向图G1：
{ A B C D E F } 
{ B A C D E F } 
{ C A B E D F } 
{ D A B C E F } 
{ E B A C D F } 
{ F D A B C E } 
广度优先遍历非连通图，无向图G1：
{ A B C D E F } 
{ B A C E D F } 
{ C A B D E F } 
{ D A C E F B } 
{ E B C D A F } 
{ F D A C E B } 

插入边(4,5,11)，(5,4,11)
带权无向图G3，顶点集合：(A, B, C, D, E, F)
邻接矩阵：
     0    45    28    10    ∞    ∞
    45     0    12    ∞    21    ∞
    28    12     0    17    26    ∞
    10    ∞    17     0    15    13
    ∞    21    26    15     0    11
    ∞    ∞    ∞    13    11     0
邻接表：
0 -> ((0,1,45), (0,2,28), (0,3,10))
1 -> ((1,0,45), (1,2,12), (1,4,21))
2 -> ((2,0,28), (2,1,12), (2,3,17), (2,4,26))
3 -> ((3,0,10), (3,2,17), (3,4,15), (3,5,13))
4 -> ((4,1,21), (4,2,26), (4,3,15), (4,5,11))
5 -> ((5,3,13), (5,4,11))

mst数组：(0,1,45) (0,2,28) (0,3,10) (0,4,9999) (0,5,9999) 
mst数组：(0,3,10) (3,2,17) (0,1,45) (3,4,15) (3,5,13) 
mst数组：(0,3,10) (3,5,13) (0,1,45) (5,4,11) (3,2,17) 
mst数组：(0,3,10) (3,5,13) (5,4,11) (4,1,21) (3,2,17) 
mst数组：(0,3,10) (3,5,13) (5,4,11) (3,2,17) (2,1,12) 
最小生成树的边集合：(0,3,10) (3,5,13) (5,4,11) (3,2,17) (2,1,12) ，最小代价为63

Dijkstra算法，单源最短路径
(A,D,C,B)39	    (A,D,C)27	(A,D)10	    (A,D,E)25	(A,D,F)23	
(B,C,D,A)39	    (B,C)12	    (B,C,D)29	(B,E)21	    (B,E,F)32	
(C,D,A)27	    (C,B)12	    (C,D)17	    (C,E)26	    (C,D,F)30	
(D,A)10	        (D,C,B)29	(D,C)17	    (D,E)15	    (D,F)13	
(E,D,A)25	    (E,B)21	    (E,C)26	    (E,D)15	    (E,F)11	
(F,D,A)23	    (F,E,B)32	(F,D,C)30	(F,D)13	    (F,E)11	

Floyd算法，每对顶点间的最短路径
(A,D,C,B)39	    (A,D,C)27	(A,D)10	    (A,D,E)25	(A,D,F)23	
(B,C,D,A)39	    (B,C)12	    (B,C,D)29	(B,E)21	    (B,E,F)32	
(C,D,A)27	    (C,B)12	    (C,D)17	    (C,E)26	    (C,D,F)30	
(D,A)10	        (D,C,B)29	(D,C)17	    (D,E)15	    (D,F)13	
(E,D,A)25	    (E,B)21	    (E,C)26	    (E,D)15	    (E,F)11	
(F,D,A)23	    (F,E,B)32	(F,D,C)30	(F,D)13	    (F,E)11	

dist矩阵（6×6）：
     0    45    28    10  9999  9999
    45     0    12  9999    21  9999
    28    12     0    17    26  9999
    10  9999    17     0    15    13
  9999    21    26    15     0    11
  9999  9999  9999    13    11     0
path矩阵（6×6）：
    -1     0     0     0    -1    -1
     1    -1     1    -1     1    -1
     2     2    -1     2     2    -1
     3    -1     3    -1     3     3
    -1     4     4     4    -1     4
    -1    -1    -1     5     5    -1

用顶点A作为其他路径的经过顶点，dist矩阵（6×6）：
     0    45    28    10  9999  9999
    45     0    12    55    21  9999
    28    12     0    17    26  9999
    10    55    17     0    15    13
  9999    21    26    15     0    11
  9999  9999  9999    13    11     0
path矩阵（6×6）：
    -1     0     0     0    -1    -1
     1    -1     1     0     1    -1
     2     2    -1     2     2    -1
     3     0     3    -1     3     3
    -1     4     4     4    -1     4
    -1    -1    -1     5     5    -1

用顶点B作为其他路径的经过顶点，dist矩阵（6×6）：
     0    45    28    10    66  9999
    45     0    12    55    21  9999
    28    12     0    17    26  9999
    10    55    17     0    15    13
    66    21    26    15     0    11
  9999  9999  9999    13    11     0
path矩阵（6×6）：
    -1     0     0     0     1    -1
     1    -1     1     0     1    -1
     2     2    -1     2     2    -1
     3     0     3    -1     3     3
     1     4     4     4    -1     4
    -1    -1    -1     5     5    -1

用顶点C作为其他路径的经过顶点，dist矩阵（6×6）：
     0    40    28    10    54  9999
    40     0    12    29    21  9999
    28    12     0    17    26  9999
    10    29    17     0    15    13
    54    21    26    15     0    11
  9999  9999  9999    13    11     0
path矩阵（6×6）：
    -1     2     0     0     2    -1
     2    -1     1     2     1    -1
     2     2    -1     2     2    -1
     3     2     3    -1     3     3
     2     4     4     4    -1     4
    -1    -1    -1     5     5    -1

用顶点D作为其他路径的经过顶点，dist矩阵（6×6）：
     0    39    27    10    25    23
    39     0    12    29    21    42
    27    12     0    17    26    30
    10    29    17     0    15    13
    25    21    26    15     0    11
    23    42    30    13    11     0
path矩阵（6×6）：
    -1     2     3     0     3     3
     3    -1     1     2     1     3
     3     2    -1     2     2     3
     3     2     3    -1     3     3
     3     4     4     4    -1     4
     3     2     3     5     5    -1

用顶点E作为其他路径的经过顶点，dist矩阵（6×6）：
     0    39    27    10    25    23
    39     0    12    29    21    32
    27    12     0    17    26    30
    10    29    17     0    15    13
    25    21    26    15     0    11
    23    32    30    13    11     0
path矩阵（6×6）：
    -1     2     3     0     3     3
     3    -1     1     2     1     4
     3     2    -1     2     2     3
     3     2     3    -1     3     3
     3     4     4     4    -1     4
     3     4     3     5     5    -1

用顶点F作为其他路径的经过顶点，dist矩阵（6×6）：
     0    39    27    10    25    23
    39     0    12    29    21    32
    27    12     0    17    26    30
    10    29    17     0    15    13
    25    21    26    15     0    11
    23    32    30    13    11     0
path矩阵（6×6）：
    -1     2     3     0     3     3
     3    -1     1     2     1     4
     3     2    -1     2     2     3
     3     2     3    -1     3     3
     3     4     4     4    -1     4
     3     4     3     5     5    -1

Floyd算法，每对顶点间的最短路径
(A,D,C,B)39	(A,D,C)27	(A,D)10	(A,D,E)25	(A,D,F)23	
(B,C,D,A)39	(B,C)12	(B,C,D)29	(B,E)21	(B,E,F)32	
(C,D,A)27	(C,B)12	(C,D)17	(C,E)26	(C,D,F)30	
(D,A)10	(D,C,B)29	(D,C)17	(D,E)15	(D,F)13	
(E,D,A)25	(E,B)21	(E,C)26	(E,D)15	(E,F)11	
(F,D,A)23	(F,E,B)32	(F,D,C)30	(F,D)13	(F,E)11	

删除顶点D，顶点集合：(A, B, C, E, F)
邻接矩阵：
     0    45    28    ∞    ∞
    45     0    12    21    ∞
    28    12     0    26    ∞
    ∞    21    26     0    11
    ∞    ∞    ∞    11     0
邻接表：
0 -> ((0,1,45), (0,2,28))
1 -> ((1,0,45), (1,2,12), (1,3,21))
2 -> ((2,0,28), (2,1,12), (2,3,26))
3 -> ((3,1,21), (3,2,26), (3,4,11))
4 -> ((4,3,11))

删除边(3,4,9999)，(F,E)，插入顶点G，顶点集合：(A, B, C, E, F, G, H, I, J, K)
邻接矩阵：
     0    45    28    ∞    ∞    ∞    ∞    ∞    ∞    ∞
    45     0    12    21    ∞    ∞    ∞    ∞    ∞    ∞
    28    12     0    26    ∞    ∞    ∞    ∞    ∞    ∞
    ∞    21    26     0    ∞    ∞    ∞    ∞    ∞    ∞
    ∞    ∞    ∞    ∞     0    ∞    ∞    ∞    ∞    ∞
    ∞    ∞    ∞    ∞    ∞     0     0    ∞    ∞    ∞
    ∞    ∞    ∞    ∞    ∞     0     0    ∞    ∞    ∞
    ∞    ∞    ∞    ∞    ∞    ∞    ∞     0    ∞    ∞
    ∞    ∞    ∞    ∞    ∞    ∞    ∞    ∞     0    ∞
    ∞    ∞    ∞    ∞    ∞    ∞    ∞    ∞    ∞     0
邻接表：
0 -> ((0,1,45), (0,2,28))
1 -> ((1,0,45), (1,2,12), (1,3,21))
2 -> ((2,0,28), (2,1,12), (2,3,26))
3 -> ((3,1,21), (3,2,26))
4 -> ()
5 -> ()
6 -> ()
7 -> ()
8 -> ()
9 -> ()
*/

