//【例10.3】使用最小堆实现Kruskal算法。

#include "MinSpanTree.h"

int main()
{
    Triple edges[]={Triple(0,1,26), Triple(0,2,28), Triple(0,3,15), Triple(1,2,17),
        Triple(1,4,13), Triple(2,3,25), Triple(2,4,21), Triple(2,5,14), Triple(3,5,18), 
        Triple(4,5,16)};                                  //第3版图10.8，带权无向图G6的边集合（每边只表示一次）
    MinSpanTree mstree(6, edges, 10);

    system("pause");
    return 0;
}

/*
程序运行结果如下：
并查集：(-1, -1, -1, -1, -1, -1)
最小堆：((1,4,13), (2,5,14), (2,4,21), (0,3,15), (4,5,16), (0,1,26), (2,3,25), (0,2,28), (3,5,18), (1,2,17))
最小边(1,4,13)，插入边(1,4,13)，并查集：(-1, -2, -1, -1, 1, -1)
最小边(2,5,14)，插入边(2,5,14)，并查集：(-1, -2, -2, -1, 1, 2)
最小边(0,3,15)，插入边(0,3,15)，并查集：(-2, -2, -2, 0, 1, 2)
最小边(4,5,16)，插入边(4,5,16)，并查集：(-2, -4, 1, 0, 1, 2)
最小边(1,2,17)，最小边(3,5,18)，插入边(3,5,18)，并查集：(1, -6, 1, 0, 1, 2)
带权无向图G6，最小生成树的边集合：(1,4,13) (2,5,14) (0,3,15) (4,5,16) (3,5,18) ，最小代价为76

//按照折叠规则压缩路径
最小边(1,2,17)，最小边(3,5,18)，插入边(3,5,18)，并查集：(1, -6, 1, 0, 1, 1) 


*/
