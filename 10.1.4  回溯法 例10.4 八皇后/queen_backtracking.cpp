//10.1.4   回溯法
//【例10.4】 用回溯法求解八皇后问题。

#include <iostream>
using namespace std;
#include "SeqList.h"                                       //顺序表类（第2章）
#include<math.h>                                           //包含abs(i)函数，返回i绝对值

class Queen                                                //求解n皇后问题，默认八皇后
{
  private:
    int n;                                                 //皇后个数，即棋盘大小
    SeqList<int> x;                                        //一个n元组，保存一个解
    int count;                                             //记录解的个数

    bool place(int i);                                     //测试x[i]位置是否可放皇后
    void backtrack(int i);                                 //递归回溯，输出所有解
    void backtrack();                                      //迭代回溯，输出所有解

  public:
    Queen(int n=8);                                        //构造函数，n指定皇后个数，默认八皇后
};

Queen::Queen(int n) : x(n,0)                               //构造函数，声明执行SeqList<T>(int length, T x)
{
    if (n>0 && n<=8)
    {
        this->n = n;                                       //皇后个数
        this->count=0;                                     //记录解的个数
//        this->backtrack(0);                                //递归回溯，输出所有解
        this->backtrack();                                 //迭代回溯，输出所有解
        cout<<this->n<<"皇后，"<<count<<"个解。\n"<<endl;
    }
    else throw out_of_range("参数n指定皇后数超出范围");
}

bool Queen::place(int i)                                   //测试x[i]位置是否可放皇后
{
    for (int j=0; j<i; j++)
        if (abs(i-j)==abs(x[j]-x[i]) || x[j]==x[i])
            return false;
    return true;
}

void Queen::backtrack(int i)                               //递归回溯，输出所有解
{
    if (i<n)
        for (int j=0; j<n; j++) 
        {
            x[i]=j;                                        //记住一个皇后位置
            if (place(i))
                backtrack(i+1);                            //测试下一个位置
        }
    else
    {
        count++;                                           //解的计数
        cout<<x;                                           //输出一个解
    }
}

void Queen::backtrack()                                    //迭代回溯，输出所有解
{
    x[0]=-1;
    int i=0;
    while (i>=0)
    {
        do
            x[i]++;
        while (x[i]<n && !place(i));                       //寻找第i个皇后位置

        if (x[i]<n)                                        //找到第i个皇后位置为x[i]
            if (i!=n-1)
                x[++i]=-1;                                 //继续寻找第i+1个皇后位置
            else                                           //求得一个解
            {
                count++;
                cout<<x;                                   //输出一个解
            }
        else i--;                        //没有找到第i个皇后位置，退回到第i-1个皇后位置，继续搜索其他路径
    }
}

int main()
{
    for (int n=1; n<=8; n++)
        Queen q(n);

    system("pause");
    return 0;
}

/*
程序运行结果如下：
Queen(1)：
(1)
count=1

Queen(2)：
count=0

Queen(3)：
count=0

Queen(4)：
(2,4,1,3)
(3,1,4,2)
count=2

Queen(5)：
(1,3,5,2,4)
(1,4,2,5,3)
(2,4,1,3,5)
(2,5,3,1,4)
(3,1,4,2,5)
(3,5,2,4,1)
(4,1,3,5,2)
(4,2,5,3,1)
(5,2,4,1,3)
(5,3,1,4,2)
count=10

Queen(6)：
(2,4,6,1,3,5)
(3,6,2,5,1,4)
(4,1,5,2,6,3)
(5,3,1,6,4,2)
count=4


Queen(7)：
(1,3,5,7,2,4,6)
(1,4,7,3,6,2,5)
(1,5,2,6,3,7,4)
(1,6,4,2,7,5,3)
(2,4,1,7,5,3,6)
(2,4,6,1,3,5,7)
(2,5,1,4,7,3,6)
(2,5,3,1,7,4,6)
(2,5,7,4,1,3,6)
(2,6,3,7,4,1,5)
(2,7,5,3,1,6,4)
(3,1,6,2,5,7,4)
(3,1,6,4,2,7,5)
(3,5,7,2,4,6,1)
(3,6,2,5,1,4,7)
(3,7,2,4,6,1,5)
(3,7,4,1,5,2,6)
(4,1,3,6,2,7,5)
(4,1,5,2,6,3,7)
(4,2,7,5,3,1,6)
(4,6,1,3,5,7,2)
(4,7,3,6,2,5,1)
(4,7,5,2,6,1,3)
(5,1,4,7,3,6,2)
(5,1,6,4,2,7,3)
(5,2,6,3,7,4,1)
(5,3,1,6,4,2,7)
(5,7,2,4,6,1,3)
(5,7,2,6,3,1,4)
(6,1,3,5,7,2,4)
(6,2,5,1,4,7,3)
(6,3,1,4,7,5,2)
(6,3,5,7,1,4,2)
(6,3,7,4,1,5,2)
(6,4,2,7,5,3,1)
(6,4,7,1,3,5,2)
(7,2,4,6,1,3,5)
(7,3,6,2,5,1,4)
(7,4,1,5,2,6,3)
(7,5,3,1,6,4,2)
count=40

Queen(8)：
(1,5,8,6,3,7,2,4)
(1,6,8,3,7,4,2,5)
(1,7,4,6,8,2,5,3)
(1,7,5,8,2,4,6,3)
(2,4,6,8,3,1,7,5)
(2,5,7,1,3,8,6,4)
(2,5,7,4,1,8,6,3)
(2,6,1,7,4,8,3,5)
(2,6,8,3,1,4,7,5)
(2,7,3,6,8,5,1,4)
(2,7,5,8,1,4,6,3)
(2,8,6,1,3,5,7,4)
(3,1,7,5,8,2,4,6)
(3,5,2,8,1,7,4,6)
(3,5,2,8,6,4,7,1)
(3,5,7,1,4,2,8,6)
(3,5,8,4,1,7,2,6)
(3,6,2,5,8,1,7,4)
(3,6,2,7,1,4,8,5)
(3,6,2,7,5,1,8,4)
(3,6,4,1,8,5,7,2)
(3,6,4,2,8,5,7,1)
(3,6,8,1,4,7,5,2)
(3,6,8,1,5,7,2,4)
(3,6,8,2,4,1,7,5)
(3,7,2,8,5,1,4,6)
(3,7,2,8,6,4,1,5)
(3,8,4,7,1,6,2,5)
(4,1,5,8,2,7,3,6)
(4,1,5,8,6,3,7,2)
(4,2,5,8,6,1,3,7)
(4,2,7,3,6,8,1,5)
(4,2,7,3,6,8,5,1)
(4,2,7,5,1,8,6,3)
(4,2,8,5,7,1,3,6)
(4,2,8,6,1,3,5,7)
(4,6,1,5,2,8,3,7)
(4,6,8,2,7,1,3,5)
(4,6,8,3,1,7,5,2)
(4,7,1,8,5,2,6,3)
(4,7,3,8,2,5,1,6)
(4,7,5,2,6,1,3,8)
(4,7,5,3,1,6,8,2)
(4,8,1,3,6,2,7,5)
(4,8,1,5,7,2,6,3)
(4,8,5,3,1,7,2,6)
(5,1,4,6,8,2,7,3)
(5,1,8,4,2,7,3,6)
(5,1,8,6,3,7,2,4)
(5,2,4,6,8,3,1,7)
(5,2,4,7,3,8,6,1)
(5,2,6,1,7,4,8,3)
(5,2,8,1,4,7,3,6)
(5,3,1,6,8,2,4,7)
(5,3,1,7,2,8,6,4)
(5,3,8,4,7,1,6,2)
(5,7,1,3,8,6,4,2)
(5,7,1,4,2,8,6,3)
(5,7,2,4,8,1,3,6)
(5,7,2,6,3,1,4,8)
(5,7,2,6,3,1,8,4)
(5,7,4,1,3,8,6,2)
(5,8,4,1,3,6,2,7)
(5,8,4,1,7,2,6,3)
(6,1,5,2,8,3,7,4)
(6,2,7,1,3,5,8,4)
(6,2,7,1,4,8,5,3)
(6,3,1,7,5,8,2,4)
(6,3,1,8,4,2,7,5)
(6,3,1,8,5,2,4,7)
(6,3,5,7,1,4,2,8)
(6,3,5,8,1,4,2,7)
(6,3,7,2,4,8,1,5)
(6,3,7,2,8,5,1,4)
(6,3,7,4,1,8,2,5)
(6,4,1,5,8,2,7,3)
(6,4,2,8,5,7,1,3)
(6,4,7,1,3,5,2,8)
(6,4,7,1,8,2,5,3)
(6,8,2,4,1,7,5,3)
(7,1,3,8,6,4,2,5)
(7,2,4,1,8,5,3,6)
(7,2,6,3,1,4,8,5)
(7,3,1,6,8,5,2,4)
(7,3,8,2,5,1,6,4)
(7,4,2,5,8,1,3,6)
(7,4,2,8,6,1,3,5)
(7,5,3,1,6,8,2,4)
(8,2,4,1,7,5,3,6)
(8,2,5,3,1,7,4,6)
(8,3,1,6,2,5,7,4)
(8,4,1,3,6,2,7,5)
count=92


Queen(4)：
(1)
(1,1)
(1,2)
(1,3)
(1,3,1)
(1,3,2)
(1,3,3)
(1,3,4)
(1,4)
(1,4,1)
(1,4,2)
(1,4,2,1)
(1,4,2,2)
(1,4,2,3)
(1,4,2,4)
(1,4,3)
(1,4,4)
(2)
(2,1)
(2,2)
(2,3)
(2,4)
(2,4,1)
(2,4,1,1)
(2,4,1,2)
(2,4,1,3)
(2,4,1,3)
(2,4,1,4)
(2,4,2)
(2,4,3)
(2,4,4)
(3)
(3,1)
(3,1,1)
(3,1,2)
(3,1,3)
(3,1,4)
(3,1,4,1)
(3,1,4,2)
(3,1,4,2)
(3,1,4,3)
(3,1,4,4)
(3,2)
(3,3)
(3,4)
(4)
(4,1)
(4,1,1)
(4,1,2)
(4,1,3)
(4,1,3,1)
(4,1,3,2)
(4,1,3,3)
(4,1,3,4)
(4,1,4)
(4,2)
(4,2,1)
(4,2,2)
(4,2,3)
(4,2,4)
(4,3)
(4,4)
count=2

*/