//《数据结构（C++版）（第3版）》 作者：叶核亚
//【例9.1】调用排序算法。

#include "Array.h"                                           //数组运算（第1章），包含random(keys,N)、print(keys,n)和排序等函数

int main() 
{
//    int keys[] = {32,26,87,72,26,17};                      //图9.1数据序列，直接插入排序；图9.3 冒泡排序
//    int keys[] = {1,2,3,4,5,6,7,8};                        //升序序列，直接插入排序；冒泡排序；快速排序；最小堆；归并排序
//    int keys[] = {8,7,6,5,4,3,2,1};                        //降序序列，直接插入排序；冒泡排序；快速排序；最大堆；归并排序
//    int keys[] = {3,1,2,4,5,8,6,7};                        //接近有序，直接插入排序；冒泡排序
//    int keys[] = {38,55,65,97,27,76,27,13,19};             //希尔排序，图9.2
//    int keys[] = {4,5,8,1,2,7,3,6};                        //冒泡排序，没有交换信号量时
//    int keys[] = {38,38,97,75,61,19,26,49};                //快速排序，图9.5、图9.6，第3版
//    int keys[] = {38,97,26,19,38,5};                       //直接选择排序，图9.7
//      int keys[] = {81,49,19,38,97,76,13,27};              //堆排序，图9.10，第4版
    int keys[]={97,82,75,53,17,61,70,12,61,58,26};        //归并排序，图9.11，归并排序算法稳定


    cout<<"关键字序列：";
    int n=11; 
    print(keys, n);                                        //输出数组元素，声明在Array.h文件
//    insertSort(keys, n);                                     //直接插入排序（升序），声明在Array.h
//    shellSort(keys, n);                                        //希尔排序（升序）
//    bubbleSort(keys, n);                                       //冒泡排序
//    quickSort(keys, n);                                 //快速排序
//    selectSort(keys, n);                                   //直接选择排序
//    heapSort_down(keys, n);                             //堆排序（降序）最小堆，堆排序算法不稳定
    mergeSort(keys, n);

    system("pause");
    return 0;
}

/*
程序运行结果如下：

9.2.1 直接插入排序
关键字序列：32  26  87  72  26  17                         //图9.1，直接插入排序算法稳定
第1趟  temp=26	  26  32  87  72  26  17  
第2趟  temp=87	  26  32  87  72  26  17  
第3趟  temp=72	  26  32  72  87  26  17  
第4趟  temp=26	  26  26  32  72  87  17 
第5趟  temp=17	  17  26  26  32  72  87  

关键字序列：1  2  3  4  5  6                               //升序序列，直接插入排序最好情况，O(n)
第1趟  temp=2	  1  2  3  4  5  6  
第2趟  temp=3	  1  2  3  4  5  6  
第3趟  temp=4	  1  2  3  4  5  6  
第4趟  temp=5	  1  2  3  4  5  6 
第5趟  temp=6	  1  2  3  4  5  6  

关键字序列：3  1  2  4  5  8  6  7                         //接近有序，较好情况
第1趟  temp=1	  1  3  2  4  5  8  6  7  
第2趟  temp=2	  1  2  3  4  5  8  6  7  
第3趟  temp=4	  1  2  3  4  5  8  6  7  
第4趟  temp=5	  1  2  3  4  5  8  6  7  
第5趟  temp=8	  1  2  3  4  5  8  6  7  
第6趟  temp=6	  1  2  3  4  5  6  8  7  
第7趟  temp=7	  1  2  3  4  5  6  7  8  

关键字序列：6  5  4  3  2  1                               //降序序列，直接插入排序最坏情况，O(n×n)
第1趟  temp=5	  5  6  4  3  2  1  
第2趟  temp=4	  4  5  6  3  2  1  
第3趟  temp=3	  3  4  5  6  2  1  
第4趟  temp=2	  2  3  4  5  6  1  
第5趟  temp=1	  1  2  3  4  5  6  


关键字序列：1  2  3  4  5  6  7  8                         //希尔排序，升序序列
delta=4  1  2  3  4  5  6  7  8  
delta=2  1  2  3  4  5  6  7  8  
delta=1  1  2  3  4  5  6  7  8  

关键字序列：3  1  2  4  5  8  6  7                         //希尔排序，接近有序
delta=4  3  1  2  4  5  8  6  7  
delta=2  2  1  3  4  5  7  6  8  
delta=1  1  2  3  4  5  6  7  8  

关键字序列：8  7  6  5  4  3  2  1                         //希尔排序，降序序列
delta=4  4  3  2  1  8  7  6  5  
delta=2  2  1  4  3  6  5  8  7  
delta=1  1  2  3  4  5  6  7  8  


关键字序列:  32 26 87 72 26 17                             //冒泡排序，图9.3，排序算法稳定
第1趟排序:  26 32 72 26 17 87
第2趟排序:  26 32 26 17 72 87
第3趟排序:  26 26 17 32 72 87
第4趟排序:  26 17 26 32 72 87
第5趟排序:  17 26 26 32 72 87

关键字序列:  1 2 3 4 5 6 7 8                               //升序序列，冒泡排序最好情况，O(n)
第1趟排序:  1 2 3 4 5 6 7 8

    int table3[]={3,1,2,4,5,8,6,7};                        //接近有序，冒泡排序较好情况，二趟

关键字序列:  1 3 2 4 5 8 6 7                               //接近有序，冒泡排序较好情况，二趟
第1趟排序:  1 2 3 4 5 6 7 8
第2趟排序:  1 2 3 4 5 6 7 8

关键字序列:  4 5 8 1 2 7 3 6                               //冒泡排序，没有交换信号量时
第1趟排序:  4 5 1 2 7 3 6 8
第2趟排序:  4 1 2 5 3 6 7 8
第3趟排序:  1 2 4 3 5 6 7 8
第4趟排序:  1 2 3 4 5 6 7 8
第5趟排序:  1 2 3 4 5 6 7 8

关键字序列:  8 7 6 5 4 3 2 1                               //降序序列，冒泡排序最坏情况，O(n×n)
第1趟:  7 6 5 4 3 2 1 8
第2趟:  6 5 4 3 2 1 7 8
第3趟:  5 4 3 2 1 6 7 8
第4趟:  4 3 2 1 5 6 7 8
第5趟:  3 2 1 4 5 6 7 8
第6趟:  2 1 3 4 5 6 7 8
第7趟:  1 2 3 4 5 6 7 8


关键字序列：38  38  97  75  61  19  26  49                 //快速排序，图9.5、9.6，快速排序算法不稳定
0..7, vot=38,  26  38  19  38  61  75  97  49  
0..2, vot=26,  19  26  38  38  61  75  97  49  
4..7, vot=61,  19  26  38  38  49  61  97  75  
6..7, vot=97,  19  26  38  38  49  61  75  97  


关键字序列:  1 2 3 4 5 6 7 8                               //升序序列，快速排序最坏情况，O(n×n)
0..7,  vot=1   1 2 3 4 5 6 7 8
1..7,  vot=2   1 2 3 4 5 6 7 8
2..7,  vot=3   1 2 3 4 5 6 7 8
3..7,  vot=4   1 2 3 4 5 6 7 8
4..7,  vot=5   1 2 3 4 5 6 7 8
5..7,  vot=6   1 2 3 4 5 6 7 8
6..7,  vot=7   1 2 3 4 5 6 7 8

关键字序列:  8 7 6 5 4 3 2 1                               //降序序列，快速排序最坏情况，O(n×n)
0..7,  vot=8   1 7 6 5 4 3 2 8
0..6,  vot=1   1 7 6 5 4 3 2 8
1..6,  vot=7   1 2 6 5 4 3 7 8
1..5,  vot=2   1 2 6 5 4 3 7 8
2..5,  vot=6   1 2 3 5 4 6 7 8
2..4,  vot=3   1 2 3 5 4 6 7 8
3..4,  vot=5   1 2 3 4 5 6 7 8


关键字序列:  38 97 26 19 38 5                              //直接选择排序图9.7
第1趟:  5 97 26 19 38 38
第2趟:  5 19 26 97 38 38
第3趟:  5 19 26 97 38 38
第4趟:  5 19 26 38 97 38
第5趟:  5 19 26 38 38 97


关键字序列:  81 49 19 38 97 76 13 27                       //堆排序，图9.10，第4版
最小堆？ false
建立最小堆序列
sift  3..7   81 49 19 27 97 76 13 38
sift  2..7   81 49 13 27 97 76 19 38
sift  1..7   81 27 13 38 97 76 19 49
sift  0..7   13 27 19 38 97 76 81 49
最小堆？ true
堆排序（降序）
sift  0..6   19 27 49 38 97 76 81 13
sift  0..5   27 38 49 81 97 76 19 13
sift  0..4   38 76 49 81 97 27 19 13
sift  0..3   49 76 97 81 38 27 19 13
sift  0..2   76 81 97 49 38 27 19 13
sift  0..1   81 97 76 49 38 27 19 13
sift  0..0   97 81 76 49 38 27 19 13


关键字序列：97  82  75  53  17  61  70  12  61  58  26     //归并排序，图9.11
子序列长度n=1  82  97  53  75  17  61  12  70  58  61  26  
子序列长度n=2  53  75  82  97  12  17  61  70  26  58  61  
子序列长度n=4  12  17  53  61  70  75  82  97  26  58  61  
子序列长度n=8  12  17  26  53  58  61  61  70  75  82  97  //归并排序算法稳定


关键字序列：1  2  3  4  5  6  7  8                         //已排序（升序）序列，归并排序
子序列长度n=1  1  2  3  4  5  6  7  8  
子序列长度n=2  1  2  3  4  5  6  7  8  
子序列长度n=4  1  2  3  4  5  6  7  8  

关键字序列：8  7  6  5  4  3  2  1                         //已排序（降序）序列，归并排序
子序列长度n=1  7  8  5  6  3  4  1  2  
子序列长度n=2  5  6  7  8  1  2  3  4  
子序列长度n=4  1  2  3  4  5  6  7  8  

*/
